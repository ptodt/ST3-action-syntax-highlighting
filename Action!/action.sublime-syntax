%YAML 1.2
---
name: Action!
file_extensions: [act]
scope: source.action

variables:
  base_type: '(?i)\b(ARRAY|BYTE|POINTER|CARD|CHAR|INT)\b'

  decimal: '\b(-)?[0-9.]+\b'
  hexadecimal: '("?)\$[0-9a-fA-F]+("?)'

  reserved: '(?i)\b(AND|FI|OR|UNTIL|FOR|WHILE|XOR|IF|RETURN|INCLUDE|RSH|SET|DO|LSH|STEP|ELSE|MOD|THEN|ELSEIF|MODULE|TO|EXIT|OD|TYPE)\b'

  procedures: '(?i)\b(Print|PrintE|PrintD|PrintDE|PrintB|PrintBE|PrintBD|PrintBDE|PrintC|PrintCE|PrintCD|PrintCDE|PrintI|PrintIE|PrintID|PrintIDE|Put|PutE|PutD|PutDE|InputS|InputSD|InputMD|Open|Close|XIO|Note|Point|Graphics|SetColor|Plot|DrawTo|Fill|Position|Sound|SndRst|SCopy|SCopyS|SAssign|StrB|StrC|StrI|Break|Error|Zero|SetBlock|MoveBlock)\b'
  functions: '(?i)\b(InputB|InputC|InputI|InputBD|InpuCD|InputID|GetD|Locate|Paddle|PTrig|Stick|STrig|SCompare|ValB|ValC|ValI|Rand|Peek|PeekC|Poke|PokeC)\b'

  identifier: '[A-Za-z_][A-Za-z_0-9]*'

contexts:
  main:
    - include: global
    - include: comment
    - include: library-functions
    - include: library-procedures
    - include: reserved-keywords
    - include: base-types
    - include: functions
    - include: function-call
    - include: operators-basic
    - include: operators-bitwise
    - include: operators-augmented
    - include: operators-equality
    - include: operators-assignment
    - include: numbers-decimal
    - include: numbers-hexadecimal
    - include: identifier
    - include: double-quote

  global:
    # Handle DEFINE statements with proper scoping
    - match: '\b(DEFINE)\b'
      scope: keyword.control.action
      push: define-statement

  define-statement:
    - meta_scope: meta.define.action
    # Match variable name after DEFINE
    - match: '\s+([A-Za-z_][A-Za-z_0-9]*)'
      captures:
        1: variable.other.constant.action
      set: define-after-name
    # Exit if we hit end of line without finding name
    - match: '$'
      pop: true
    # Include comments
    - include: comment

  define-after-name:
    # Match the equals sign
    - match: '='
      scope: keyword.operator.assignment.action
      set: define-after-equals
    # Exit if we hit end of line
    - match: '$'
      pop: true
    # Include comments
    - include: comment

  define-after-equals:
    # Match quoted string value
    - match: '"'
      scope: punctuation.definition.string.begin.action
      set:
        - meta_scope: string.quoted.double.action
        - match: '"'
          scope: punctuation.definition.string.end.action
          set: define-after-value
        - match: '$'
          pop: true
    # Exit if no quote found
    - match: '$'
      pop: true
    # Include comments
    - include: comment

  define-after-value:
    # After the closing quote, allow comments
    - include: comment
    # Pop at end of line
    - match: '$'
      pop: true
    # Consume any whitespace
    - match: '\s+'

  comment:
    - match: ';'
      scope: punctuation.definition.comment.action
      push:
        - meta_scope: comment.line.action
        - match: $
          pop: true

  double-quote:
    - match: '"'
      scope: punctuation.definition.string.begin.action
      push:
        - meta_scope: string.quoted.double.action
        - match: \\.
          scope: constant.character.escape.action
        - match: '"'
          scope: punctuation.definition.string.end.action
          pop: true

  entity-name-function:
    # - include: magic-function-names
    # - include: illegal-names
    - include: generic-names

  generic-names:
    - match: '{{identifier}}'
      scope: entity.name.function

  functions:
    - match: '\b(PROC|FUNC)\b'
      scope: storage.type.function.action
      push: function-definition

  function-definition:
    - meta_scope: meta.function.action
    # Match function name (must have at least one space before)
    - match: '\s+([A-Za-z_][A-Za-z_0-9]*)'
      captures:
        1: entity.name.function.action
      set: function-after-name
    # Include comments
    - include: comment
    # Exit if we hit end of line or opening paren without name
    - match: '(?=\()|$'
      pop: true

  function-after-name:
    - meta_scope: meta.function.action
    # Match optional address assignment (=$address)
    - match: '='
      scope: keyword.operator.assignment.action
      set: function-address
    # Match opening parenthesis (parameters start)
    - match: '\('
      scope: punctuation.section.parameters.begin.action
      set: function-parameters
    # Exit at end of line
    - match: '$'
      pop: true

  function-address:
    - meta_scope: meta.function.action
    # Match hexadecimal address
    - match: '\$[0-9a-fA-F]+'
      scope: constant.numeric.hexadecimal.action
      set: function-after-address
    # Exit if no valid hex found
    - match: '(?=\()|$'
      pop: true

  function-after-address:
    - meta_scope: meta.function.action
    # Match opening parenthesis after address
    - match: '\('
      scope: punctuation.section.parameters.begin.action
      set: function-parameters
    # Exit at end of line
    - match: '$'
      pop: true

  function-parameters:
    - meta_scope: meta.function.parameters.action
    # Match closing parenthesis
    - match: '\)'
      scope: punctuation.section.parameters.end.action
      pop: true
    # Match parameter types
    - match: '{{base_type}}'
      scope: keyword.control.action
    # Match parameter names
    - match: '\b{{identifier}}\b'
      scope: variable.parameter.action
    # Match comma separator
    - match: ','
      scope: punctuation.separator.parameters.action
    # Include comments
    - include: comment

  function-call:
    - match: (\w+)\s*(?=\()
      captures:
        0: meta.function-call.action
        1: variable.function.builtin.action
      push: function-call-arguments

  function-call-arguments:
    - match: \(
      scope: punctuation.section.parameters.begin.action
      set:
        - meta_scope: meta.function-call.parameters.action
        - match: \)
          scope: punctuation.section.parameters.end.action
          pop: true
        - match: ','
          scope: punctuation.separator.parameters.action
        - include: main

  # Library functions
  library-functions:
    - match: '{{functions}}'
      scope: support.function

  library-procedures:
    - match: '{{procedures}}'
      scope: support.function

  # Reserved keywords
  reserved-keywords:
    - match: '{{reserved}}'
      scope: keyword.control.action

  # Reserved keywords
  base-types:
    - match: '{{base_type}}'
      scope: keyword.control.action

  operators-basic:
    - match: (\+|-|\*|/|%|<|>|<>|#|@)
      scope: keyword.operator.action

  operators-bitwise:
    - match: (&|\||!|\^|>>|<<)
      scope: keyword.operator.action

  operators-augmented:
    - match: ==(\+|-|\*|/|%|&|\||\^|>>|<<|\.|\?\?)
      scope: keyword.operator.action

  operators-equality:
    - match: (\+|-|\*|/|%|&|\||\^|>>|<<|\.|\?\?)=
      scope: keyword.operator.action

  operators-assignment:
    - match: "="
      scope: keyword.operator.action

  # Numbers - decimal
  numbers-decimal:
    - match: '{{decimal}}'
      scope: constant.numeric.action

  #Numbers - decimal
  numbers-hexadecimal:
    - match: '{{hexadecimal}}'
      scope: constant.numeric.action

  identifier:
    - match: '\b{{identifier}}\b'
      scope: string.other.action